#!/bin/bash

clear 

sepstr="--------------------------------------------------------------------------------"
echo "$sepstr"

echo "$sepstr"
echo "Let:"
echo "a=1"
echo "b=5"
echo "c=20"
echo "d=2"

a=1
b=5
c=20
d=2

echo "$sepstr"
echo "The operators are: "
echo "$sepstr"
echo "  ++/--"
echo "     >>echo \"\[ a++ ]\"<< gives"
echo "     $[ a++ ]"
a=1
echo "     >>echo \"\[ ++a ]\"<< gives"
echo "     $[ a++ ]"
a=1
echo "       (important for the evaluation of a in loops..."
echo "         d = a++ #has d=1, a=1"
echo "         d = ++a #has d=2, a=1)"
echo "$sepstr"
echo "  +/- (unary)"
echo "     >>echo \"\[ -a ]\"<< gives"
echo "     $[ -a ]"
a=1
echo "$sepstr"
echo "  !,~ (logical and bitwise negation)"
echo "     >>echo \"\[ !0 ]\"<< gives"
echo "     $[ !0 ]"
echo "$sepstr"
echo "  ** (exponentiation)"
echo "     >>echo \"\[ d**b ]\"<< gives"
echo "     $[ d**b ]"
echo "$sepstr"
echo "  *, /, %"
echo "     >>echo \"\[ -1 * 2]\"<< gives"
echo "     $[ -1 * 2]"
echo "$sepstr"
echo "  *+,-"
echo "     >>echo \"\[ 1+1 ]\"<< gives"
echo "     $[ 1+1 ]"
echo "$sepstr"
echo "  <<, >> (left and right shift)"
echo "     >>echo \"\[ 1 << 1 ]\"<< gives"
echo "     $[ 1 << 1]"
echo "$sepstr"
echo "  <=, >=, <, > (comparison)"
echo "     >>echo \"\[ 1 >= 3 ]\"<< gives"
echo "     $[ 1 >= 3 ]"
echo "$sepstr"
echo "  ==, !="
echo "     >>echo \"\[ 2 != 4 ]\"<< gives"
echo "     $[ 2 != 4]"
echo "$sepstr"
echo "  &, ^, | (bitwise AND, XOR, OR)"
echo "     >>echo \"\[ 7 ^ 3 ]\"<< gives"
echo "     $[ 7 ^ 3 ]"
echo "$sepstr"
echo "  &&, || (logical AND, OR)"
echo "     >>echo \"\[ 1 || 0 ]\"<< gives"
echo "     $[ 1 || 0 ]"
echo "$sepstr"
echo "  ?: (the ternary)"
echo "     >>echo \"\[ (a == b ? 1 : 0) ]\"<< gives"
echo "     $[ (a == b ? 1 : 0) ]"
echo "$sepstr"
echo "  =, *=, /=, %=, +=, -=, <<=, >>=, &=, ^=, |= (a ssignment)"
echo "     >>echo \"\[ c %= 3 ]\"<< gives"
echo "     $[ c %= 3 ]"
echo "$sepstr"
echo "  , (the expression separator)"

echo "$sepstr"
echo "$sepstr"
echo "A VERY IMPORTANT NOTE."
echo "  Internal integer storage seems to follow these rules:"
echo "  1. Signs are stored as a separate, 1-bit field."
echo "  2. For all bitwise inversions, *only the bits up to the highest significant bit* are inverted."
echo "  3. For left- and right-shifts, no byte/word boundary is observed."
echo "Per online information, this is because BASH uses intmax_t variables (which I think is a 64-bit field on my machine).  It DOES use 2's complement, but only the most significant bit is used for the sign."
echo "$sepstr"
echo "Proof:"

echo "     >>echo \"\[ ((2#1)<<63) ]\"<< gives"
echo "     $[ ((2#1)<<63) ]"
echo "     >>echo \"\[ ((2#-1)<<63) ]\"<< gives"
echo "     $[ ((2#-1)<<63) ]"
echo "     >>echo \"\[ ((2#1)<<64) ]\"<< gives"
echo "     $[ ((2#1)<<64) ]"
echo "     >>echo \"\[ ((2#-1)<<64) ]\"<< gives"
echo "     $[ ((2#-1)<<63) ]"

echo "     >>echo \"\[ ((1)<<63) ]\"<< gives"
echo "     $[ ((1)<<63) ]"
echo "     >>echo \"\[ ((-1)<<63) ]\"<< gives"
echo "     $[ ((-1)<<63) ]"


echo "     >>echo \"\[ 1<<5 ]\"<< (000...1<<5) gives (000...10000) gives (2**5):"
echo "       $[ 1<<5 ] ?= $[ 2**5 ]"
echo "     >>echo \"\[ 1<<63 ]\"<< (000...1<<63) gives (010...0) gives (2**63):"
echo "       $[ 1<<63 ] ?= $[ 2**63 ]"
echo "     >>echo \"\[ 1<<64 ]\"<< (000...1<<64) gives (10...0), which is NOT (2**64):"
echo "       $[ 1<<64 ] ?= $[ 2**64 ]"
echo "     >>echo \"\[ 6>>1 ]\"<< (000...110>>1) gives (000...11), which is NOT (2**64):"
echo "       $[ 6>>1 ] ?= $[ 2**64 ]"
echo "     >>echo \"\[ (-1<<63) +1 ]\"<< gives"
echo "     $[ (-1<<63) +1 ]"
echo "     >>echo \"\[ (-1<<63)+1 ]\"<< gives"
echo "     $[ (-1<<63)+1 ]"
echo "     >>echo \"\[ 2**64 ]\"<< gives"
echo "     $[ 2**64 ]"
echo "     >>echo \"\[ ~-4 ]\"<< gives"
echo "     $[ ~-4 ]"
echo "     >>echo \"\[ ~-7 ]\"<< gives"
echo "     $[ ~-7 ]"



